# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

################################################################################
# This script generates the an array of UiaTextRange tests suitable for replacing the body of
# src\interactivity\win32\ut_interactivity_win32\UiaTextRangeTests.cpp TEST_METHOD(GeneratedMovementTests)
#
# See tools\TestTableWriter\README.md for more details on how to use this script.

[CmdletBinding()]
Param(
    [Parameter(Position=0, ValueFromPipeline=$true)]
    [string]$TestPath = "UiaTests.csv"
)

# 0. Generate a comment telling people to not modify these tests in the .cpp
$result = "
// DO NOT MODIFY THESE TESTS DIRECTLY
// These were generated by tools\TestTableWriter\GenerateTests.ps1
// Read tools\TestTableWriter\README.md for more details"

# 1.a. Define a few helpful variables to make life easier.
$result += "
// Define a few helpful variables
const Viewport bufferSize{ Viewport::FromDimensions({ 80, 300}) };
constexpr short midX{ 40 };
constexpr short midY{ 150 };
constexpr short midPopulatedY{ 75 };
constexpr til::point origin{ 0, 0 };
constexpr til::point midTop{ midX, 0 };
constexpr til::point midHistory{ midX, midPopulatedY };
constexpr til::point docEnd{ 0, midY + 1 };`n"

# 1.b. Assert the buffer size is what we expect it to be. Otherwise, everything will be wrong.
$result += "
// Assert these variables represent what we expect them to be
VERIFY_ARE_EQUAL(_pTextBuffer->GetSize(), bufferSize);`n";

# 2. Pre-populate the buffer
$result += "
// Populate the buffer with...
// - 9 segments of alternating text
// - up to half of the buffer (vertically)
// It'll look something like this
// +---------------------------+
// |XXX   XXX   XXX   XXX   XXX|
// |XXX   XXX   XXX   XXX   XXX|
// |XXX   XXX   XXX   XXX   XXX|
// |XXX   XXX   XXX   XXX   XXX|
// |XXX   XXX   XXX   XXX   XXX|
// |                           |
// |                           |
// |                           |
// |                           |
// |                           |
// +---------------------------+
{
    short i = 0;
    auto iter{ _pTextBuffer->GetCellDataAt(bufferSize.Origin()) };
    const auto segment{ bufferSize.Width() / 9 };
    while (iter.Pos() != docEnd)
    {
        bool fill{ true };
        if (i % segment == 0)
        {
            fill = !fill;
        }

        if (fill)
        {
            _pTextBuffer->Write({ L`"X`" }, iter.Pos());
        }

        ++i;
        ++iter;
    }
}`n`n"

# 1. Import the CSV test file and find all of the variables we need
$tests = Import-Csv $TestPath;
$vars = New-Object System.Collections.Generic.SortedSet[string];
foreach ($test in $tests)
{
    $vars.Add($test.Start) > $null;
    $vars.Add($test.End) > $null;
    $vars.Add($test.Result_Start) > $null;
    $vars.Add($test.Result_End) > $null;
}

# 2. Define each of the vars
# 2.a. Some of the variables were already defined at the beginning. So let's remove those.
$vars.Remove("origin") > $null;
$vars.Remove("midTop") > $null;
$vars.Remove("midHistory") > $null;
$vars.Remove("docEnd") > $null;

# 2.b. Now all of the remaining vars can be deduced from standard vars
foreach ($var in $vars)
{
    # Extract the standard var from the name
    $standardVar = $var.Contains("Left") ? $var.Split("Left") : $var.Substring(0, $var.length - 3);

    # i. Contains number --> requires movement
    if ($var -match ".*\d+.*")
    {
        # 3rd to last character denotes the movement direction
        # P --> plus/forwards
        # M --> minus/backwards
        $moveForward = $var.substring($var.length - 3, 1) -eq 'P';

        # 2nd to last character denotes the movement amount
        $moveAmt = $var.substring($var.length -2, 1);

        # last character denotes the movement type
        switch ($var.substring($var.length - 1, 1)) {
            'C' # move by character
            {
                $result += "COORD {0} = {1};`n" -f $var, $standardVar;
                $result += "for (int i = 0; i < {0}; ++i) {{ " -f $moveAmt;
                if ($moveForward)
                {
                    $result += "bufferSize.IncrementInBounds({0}); }}`n" -f $var;
                }
                else
                {
                    $result += "bufferSize.DecrementInBounds({0}); }}`n" -f $var;
                }
            }
            'L' # move by line
            {
                if ($moveForward)
                {
                    $result += "const til::point {0}{{ bufferSize.Left(), {1}.y() + {2} }};`n" -f $var, $standardVar, $moveAmt;
                }
                else
                {
                    $result += "const til::point {0}{{ bufferSize.Left(), {1}.y() - {2} }};`n" -f $var, $standardVar, $moveAmt;
                }
            }
            Default { Write-Host "Error: unknown variable movement type" -ForegroundColor Red }
        }
    }
    # ii. Contains "Left" --> set X to left
    elseif ($var.Contains("Left"))
    {
        $result += "const til::point " + $var + "{ bufferSize.Left(), " + $standardVar + ".y() };`n";
    }
    $result += "`n";
}

# 3. Write the tests
# 3.a. Introduce a struct to store each test as
$result += "struct GeneratedMovementTestInput
{
    TextUnit unit;
    int moveAmount;
    til::point start;
    til::point end;
};
struct GeneratedMovementTestExpected
{
    int moveAmount;
    til::point start;
    til::point end;
};
struct GeneratedMovementTest
{
    std::wstring name;
    GeneratedMovementTestInput input;
    GeneratedMovementTestExpected expected;
    bool skip;
};`n`n";

# 3.b. Iterate through CSV file and generate a test for each one
$result += "const std::array<GeneratedMovementTest, {0}> _movementTests`n{{`n" -f $tests.count;
foreach ($test in $tests)
{
    $degeneratePrefix = $test.degenerate -eq "TRUE" ? "" : "non-";
    $movementType = $test.TextUnit.substring(9);
    $testName = "L`"Move {0}degenerate range at position {1} {2} times by {3}`"" -f $degeneratePrefix, $test.Position, $test.MoveAmount, $movementType;
    $testInput = "GeneratedMovementTestInput{{
            TextUnit::{0},
            {1},
            {2},
            {3}
        }}" -f $test.TextUnit, $test.MoveAmount, $test.Start, $test.End;
    $testExpected = "GeneratedMovementTestExpected{{
            {0},
            {1},
            {2}
        }}" -f $test.Result_MoveAmount, $test.Result_Start, $test.Result_End;
    $skip = $test.Skip -eq "TRUE" ? "true" : "false";

    $result += "    GeneratedMovementTest{{
        {0},
        {1},
        {2},
        {3}
    }},`n" -f $testName, $testInput, $testExpected, $skip;
    if ($failingTests.Contains($testName))
    {
        $result += "*/";
    }
}
$result += "};`n`n"

# 4. Actually run the tests
$result += "Microsoft::WRL::ComPtr<UiaTextRange> utr;
for (const auto& test: _movementTests)
{
    if (test.skip)
    {
        continue;
    }
    Log::Comment(test.name.data());
    int amountMoved;

    THROW_IF_FAILED(Microsoft::WRL::MakeAndInitialize<UiaTextRange>(&utr, _pUiaData, &_dummyProvider, test.input.start, test.input.end));
    THROW_IF_FAILED(utr->Move(test.input.unit, test.input.moveAmount, &amountMoved));

    VERIFY_ARE_EQUAL(test.expected.moveAmount, amountMoved);
    VERIFY_ARE_EQUAL(test.expected.start, til::point{utr->_start});
    VERIFY_ARE_EQUAL(test.expected.end, til::point{utr->_end});
}";

$result
